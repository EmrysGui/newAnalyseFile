S19FileUtil:

/**
 * 这是一个用来读取S19/mot文件的工具类
 * 关于地址的判断，如果前后两个地址相差超过0x20，那么相应的处理就不同。
 */

public class S19FileUtil {
    public TextView tvProgress;
    public String[] s19LineStr;
    public Context context;
    public S19LineBean s19LineBean;
    private int pageNum;
    public StringBuffer validDataString = null;
    private int motLineRecordMemoryAddrnum;
    private final int pageSize = Integer.parseInt("8000", 16) * 2;
    private final int romTail = Integer.parseInt("23FFF", 16) * 2;
    private final int romHead = Integer.parseInt("4000", 16) * 2;
    private final int iapMarknum = Integer.parseInt("BFE0", 16) * 2;
    private final int rawDataSize = Integer.parseInt("20", 16) * 2;

    //无参构造方法
    public S19FileUtil() {
    }

    //有参的构造方法，创建对象的时候可以用来传递参数
    //先传递一个页面上下文对象,还有IAPConfigFileBean类的对象
    //IAPConfigFileBean iapConfigFileBean,
    public S19FileUtil(Context context, TextView tvProgress) {
        this.context = context;
        this.tvProgress = tvProgress;
    }

    /**
     * 从文件中读取数据并存放到数组List的方法
     */
    //用于存放数据的集合
    public ArrayList<String> s19DataLineList = new ArrayList<>();
    public List<S19LineBean> s19LineBeanReturnList = null;

    //这是读取s19文件的方法
    public List<S19LineBean> readWordsFromFile(String path) {
        try {
            //使用BufferedReader一行一行读取数据
            BufferedReader br = new BufferedReader(new FileReader(new File(path)));
            String line;
            while ((line = br.readLine()) != null) {
                if (!s19DataLineList.contains(line)) {
                    s19DataLineList.add(line + "\n");
                }
            }
            s19LineStr = new String[s19DataLineList.size()];
            //把集合转换成字符串数组
            s19LineStr = s19DataLineList.toArray(s19LineStr);
            Toast.makeText(context, "读取s19文件成功!", Toast.LENGTH_SHORT).show();
            if (s19LineStr != null) {
                s19LineBeanReturnList = cutS19File(s19LineStr, path);
                Toast.makeText(context, "s19文件内容不为空", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "s19文件内容为空", Toast.LENGTH_SHORT).show();
            }
        } catch (IOException e) {
        }
        return s19LineBeanReturnList;
    }
    /**
     * s19文件格式
     * 记录类型：2个字符
     * 记录长度:  2个字符(即1个字节)，显示在记录中剩余的字节数。即
     * 记录长度 = 存储地址字节数 + 代码/数据字节数 + 校验和字节数
     * 存储地址:  2或3或4个字节(由记录类型决定)，用来表示代码/数据应该装载的起始地址。
     * 代码/数据:  0-64字符(即0-32字节)，表示需要下载到MCU中的数据。
     * 校验和:     2个字符(即1字节),校验数据，计算方法:
     * 校验和  =  0Xff – (记录长度 + 存储地址 + 代码/数据)
     * (注意，为校验和不是字符的校验和，而是实际二进制数的校验和)
     * S0： S格式文件的第一个记录，表示文件名(含路径)，存储地址部分没有使用，以0000置位。
     * 此记录表示记录的开始，无需下载到MCU。
     * S1:  地址为2字节(4个字符)的记录。
     * S2:  地址为3字节的记录。
     * S3:  地址为4字节的记录。
     * S5:  标记本文件的S1、S2、S3记录的个数(此记录不是一个S文件所必须的)。
     * S7:  地为4字节，表示程序的开始执行地址，代码/数据部分没有被使用，此行表示程序的结束，无需下载到MCU。
     * S8:  地为3字节，表示程序的开始执行地址，代码/数据部分没有被使用，此行表示程序的结束，无需下载到MCU。
     * S9:  地为2字节，表示程序的开始执行地址，代码/数据部分没有被使用，此行表示程序的结束，无需下载到MCU。
     */
    /**
     * 这个方法是用来获取s19文件每一行内容的每个字段的内容，解析文件
     * 返回的是一个List集合，类型是S19LineBean
     *
     * @param s19LineStr 每一行数据的字符串数组
     * @param path
     * @return
     */
    public List<S19LineBean> cutS19File(String[] s19LineStr, String path) {
        //用于统计运行时间
        long start = System.currentTimeMillis();
        //记录长度
        int length;
        //数据的长度
        int dataLenth;
        //结束地址
        int dataEndAddr;
        //创建S19LineBean实体类对象
        //每一行都是一个对象，所以要设置数组来存放
        List<S19LineBean> s19LineBeanDataList = new ArrayList<>();
        //遍历循环，获取每一行的字段内容
        //s19Lines.length
        // TODO: 2017/10/12  这个循环是用来获取s19文件每一行内容的每个字段的内容，可以不用去管它
        for (int i = 0; i < s19LineStr.length; i++) {
            //创建实体类对象（每一次进入循环都创建）
            s19LineBean = new S19LineBean();
            //获取文件内容的单独一行s19StrLineStr
            String s19StrLineStr = s19LineStr[i];
            if (s19StrLineStr != null) {
              //开始进行判断（头，也就是类型）（头两个字节）
                String s19LineHead = s19StrLineStr.substring(0, 2);
                if ("S0".equals(s19LineHead)) {
                    //先把这一行的数据设置到S19LineBean对象中
                    //S0： S格式文件的第一个记录，表示文件名(含路径)，存储地址部分没有使用，
                    // 以0000置位。此记录表示记录的开始，无需下载到MCU。
                    //类型
                    s19LineBean.setMotLineRecordType("S0");
                    //这个S0是要丢弃的数据
                   // s19LineBeanDataList.add(s19LineBean);
                } else if ("S1".equals(s19LineHead)) {
                    //S1:  地址为2字节的记录。
                    s19LineBean.setMotLineRecordType("S1");
                    //s19StrLineStr把行数据分段进行存储
                    //记录长度
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    //存储的起始地址
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 8));
                    //把记录长度转换成十进制
                    Byte lengthByte = clsPublic.HexString2Bytes(s19StrLineStr.substring(2, 4))[0];
                    length = lengthByte * 2;
                    //数据的长度=记录长度-存储地址字节数-校验和字节数
                    dataLenth = length - (4 + 2);
                    int dataStartAddr = clsPublic.HexString2Bytes(s19StrLineStr.substring(4, 8))[0] * 2;
                    dataEndAddr = dataStartAddr + dataLenth;
                    s19LineBean.setMotLineRecordEndAddr(Integer.toHexString(dataEndAddr));
                    //数据
                    s19LineBean.setMotLineRecordData(s19StrLineStr.substring(8, (8 + dataLenth)));
                    //校验和
                    s19LineBean.setMotLineRecordChecksum(s19StrLineStr.substring((8 + dataLenth), (8 + dataLenth + 2)));
                    //把对象添加到集合中
                    s19LineBeanDataList.add(s19LineBean);
                } else if ("S2".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S2");
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 10));
                    Byte lengthByte = clsPublic.HexString2Bytes(s19StrLineStr.substring(2, 4))[0];
                    length = lengthByte * 2;
                    dataLenth = length - (6 + 2);
                    int dataStartAddr = clsPublic.HexString2Bytes(s19StrLineStr.substring(4, 10))[0] * 2;
                    dataEndAddr = dataStartAddr + dataLenth;
                    s19LineBean.setMotLineRecordEndAddr(Integer.toHexString(dataEndAddr));
                    s19LineBean.setMotLineRecordData(s19StrLineStr.substring(10, (10 + dataLenth)));
                    s19LineBean.setMotLineRecordChecksum(s19StrLineStr.substring((10 + dataLenth), (10 + dataLenth + 2)));
                    s19LineBeanDataList.add(s19LineBean);
                } else if ("S3".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S3");
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 12));
                    Byte lengthByte = clsPublic.HexString2Bytes(s19StrLineStr.substring(2, 4))[0];
                    length = lengthByte * 2;
                    dataLenth = length - (8 + 2);
                    int dataStartAddr = clsPublic.HexString2Bytes(s19StrLineStr.substring(4, 12))[0] * 2;
                    dataEndAddr = dataStartAddr + dataLenth;
                    s19LineBean.setMotLineRecordEndAddr(Integer.toHexString(dataEndAddr));
                    s19LineBean.setMotLineRecordData(s19StrLineStr.substring(12, (12 + dataLenth)));
                    s19LineBean.setMotLineRecordChecksum(s19StrLineStr.substring((12 + dataLenth), (12 + dataLenth + 2)));
                    s19LineBeanDataList.add(s19LineBean);
                } else if ("S5".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S5");
                    //s19LineBeanDataList.add(s19LineBean);
                } else if ("S7".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S7");
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 12));
                    //s19LineBeanDataList.add(s19LineBean);
                } else if ("S8".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S8");
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 10));
                   // s19LineBeanDataList.add(s19LineBean);
                } else if ("S9".equals(s19LineHead)) {
                    s19LineBean.setMotLineRecordType("S9");
                    s19LineBean.setMotLineRecordLength(s19StrLineStr.substring(2, 4));
                    s19LineBean.setMotLineRecordMemoryAddr(s19StrLineStr.substring(4, 8));
                  //  s19LineBeanDataList.add(s19LineBean);
                } else {
                    Toast.makeText(context, "S19 File Error (A) !", Toast.LENGTH_SHORT).show();
                }
            }
        }
        BufferedWriter bw = null;
        try {
            File file = new File(path);
            //要写入数据的文件路径
            String txtPath = file.getParent().trim() + File.separator + "tmp.txt";
            bw = new BufferedWriter(new FileWriter(txtPath));
        } catch (IOException e) {
            e.printStackTrace();
        }
        //页数
        if (((romTail - romHead) % pageSize) == 0) {
            pageNum = (romTail - romHead) / pageSize;
        } else {
            pageNum = (romTail - romHead) / pageSize + 1;
        }
        //有效数据
        validDataString = new StringBuffer();
        int pageHead = 0;
        int pageTail = 0;
        List<String> restOfLastDataList = new ArrayList<>();
        for (int j = 0; j < pageNum; j++) {
            //每一页的首地址：0x4000,0xc000,0x14000,0x1c000,0x24000
            //第一页的时候0x004000-0x00BFFF
            //romHead最开始的地址
            //pageSize页大小
            pageHead = romHead + pageSize * j;//页头
            pageTail = romHead + pageSize * (j + 1);//页尾
            //循环遍历存储s19lineBean的集合
            for (int i = 0; i < s19LineBeanDataList.size(); i++) {
                //S2类型的数据才进行处理
                if ("S0".equals(s19LineBeanDataList.get(i).getMotLineRecordType()) ||
                        "S5".equals(s19LineBeanDataList.get(i).getMotLineRecordType()) ||
                        "S7".equals(s19LineBeanDataList.get(i).getMotLineRecordType()) ||
                        "S8".equals(s19LineBeanDataList.get(i).getMotLineRecordType()) ||
                        "S9".equals(s19LineBeanDataList.get(i).getMotLineRecordType())) {
                } else if ("S1".equals(s19LineBeanDataList.get(i).getMotLineRecordType())) {
                } else if ("S3".equals(s19LineBeanDataList.get(i).getMotLineRecordType())) {
                } else if ("S2".equals(s19LineBeanDataList.get(i).getMotLineRecordType())) {
                    //当前行的地址的十进制整型
                    motLineRecordMemoryAddrnum = Integer.parseInt(s19LineBeanDataList.get(i).getMotLineRecordMemoryAddr(), 16) * 2;
                    //对IapMark进行处理
                    if (motLineRecordMemoryAddrnum == iapMarknum) {
                        //BFE0=49120
                        tvProgress.append("iapMarknum:" + iapMarknum + "\n");
                        tvProgress.append("motLineRecordMemoryAddrnum:" + motLineRecordMemoryAddrnum + "\n");
                        tvProgress.append("找到IAPMARK！" + "\n");
//                        //获取到IAPMARK这一行的数据
                        String iapMarkLineData = s19LineBeanDataList.get(i).getMotLineRecordData();
//                        //地址
                        String iapMarkMemoryAddr = s19LineBeanDataList.get(i).getMotLineRecordMemoryAddr();
                        String iapMarkLine = iapMarkMemoryAddr + iapMarkLineData;
//                            s19LineBeanDataList.remove(i);
                        tvProgress.append("iapMarkLine:" + iapMarkLine + "\n");
                    } else if (motLineRecordMemoryAddrnum >= pageHead &&
                            motLineRecordMemoryAddrnum < pageTail) {
                        //(romHead + pageSize)
                        validDataString.append(s19LineBeanDataList.get(i).getMotLineRecordData());
                        if (i < (s19LineBeanDataList.size() - 1)) {
                            S19LineBean s19LineBean = s19LineBeanDataList.get(i);
                            S19LineBean s19LineBean1 = s19LineBeanDataList.get(i + 1);
                            String s19Addr0 = s19LineBean.getMotLineRecordMemoryAddr();
                            String s19Addr1 = s19LineBean1.getMotLineRecordMemoryAddr();
                            //toFormerString()这个方法就是把各个字段拼接成str
                            restOfLastDataList = PadNullDataUtil.parse(s19LineBean.toFormerString(),
                                    s19LineBean1.toFormerString());
                        }
                        /**
                         *按页来处理每一行的数据以及地址
                         * 首地址0x4000,页长度为0x8000
                         * 0xc000,0x14000,0x1c000,0x24000
                         * 每一页的最后一行如果不满一行则填充“FFF”
                         * 把所有的有效数据拼接在一个String（要去除IAPMark的那一行）里，
                         * 按照页数大小使用substring()重新分配
                         * IAPMARK这一行要预留出来，最后才写入
                         * IAPSTART—IAPEND这头尾两行要直接补F
                         * 这样会产生一个新的String（长度和内容都会改变）
                         * 然后重新分配地址，生成新的s19LineBean以及s19LineBeanDataList
                         */

                    }
                }
            }
            String restOfLastData = restOfLastDataList.get(restOfLastDataList.size() - 1);
            Log.e("Parse", "restOfLastDataParse:" + restOfLastData);
            //restOfLastData.substring(6)
            if (restOfLastData.substring(6) != null) {
                //返回的数据和地址，然后……重新弄成一条新的数据传入parse1（）中（就是在后面补F）
                String lastStr = "S2" + "20" + restOfLastData.substring(0, 6) + " " + "AA";
                PadNullDataUtil.parse1(lastStr);
            }
        }
        if (bw != null) {
            try {
                //关闭流
                bw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //有效数据的长度
        Log.e("validDataString", "长度：" + validDataString.length());
        //报空指针，也就是说上下文对象并没有传过来
        Toast.makeText(context, "cutS19Data Success!", Toast.LENGTH_SHORT).show();
        long end = System.currentTimeMillis();
        Log.e("CutS19File.cutS19Data", "剪切S19文件所需的时间为：" + (end - start) + "毫秒");
        return s19LineBeanDataList;
    }

    //这个方法是用来把整型的地址转化成6位数字的地址
    public String changeToSixHexString(int num) {
        String hex = Integer.toHexString(num).toUpperCase();
        while (hex.length() < 6) {
            hex = "0" + hex;
        }
        return hex;
    }

}


PadNullDataUtil:

/**
 * 这个工具类是用来填补前后两行地址超过0x20的数据
 * 这存在一个问题：如果刚好为20，但是中间有空格，这个好难判断，可是也无法排除它存在的可能。
 */

public class PadNullDataUtil {
    private String s19LineStr1;
    private String s19LineStr0;
    private static String strFF1;

    public PadNullDataUtil() {

    }

    public PadNullDataUtil(String s19LineStr0, String s19LineStr1) {
        this.s19LineStr0 = s19LineStr0;
        this.s19LineStr1 = s19LineStr1;
    }

    public static int getDataLength(String str) {
        String strDataLength = str.substring(2, 4);
        int dataLength = Integer.valueOf(strDataLength, 16) * 2;
        return dataLength - 8;
    }

    /**
     * 获取纯数据
     *
     * @param str
     * @return
     * @throws Exception
     */
    public static String getData(String str) {
        String substringIncludeCheckCode = str.substring(10).trim();
        int length = substringIncludeCheckCode.length();
        String data = substringIncludeCheckCode.substring(0, length - 2);//去除校验码
        return data;
    }

    /**
     * 获取地址码
     *
     * @param str
     * @return
     */
    public static String getAddressCode(String str) {
        String address = str.substring(4, 10);
        return address;
    }

    public static String changeToSixHexString(int num) {
        String hex = Integer.toHexString(num).toUpperCase();
        while (hex.length() < 6) {
            hex = "0" + hex;
        }
        return hex;
    }

    /**
     * 地址码相减
     *
     * @param addressCode1
     * @param addressCode2
     * @return
     */


    public static int calculateIntervalOfAddressCode(String addressCode1, String addressCode2) {
        int address1 = Integer.valueOf(addressCode1, 16);
        int address2 = Integer.valueOf(addressCode2, 16);
        return address2 - address1;
    }

    // 两条数据解析成一条新数据后，还剩余的数据
    private static String restOfLastData;
    private static boolean hasFinishedParseData;
    private static boolean isFirstTimeToParse = true;
    private static String addr;
    private static int address;
    private static int lackLength;
    static String restOfStr0;
    static List<String> restOfLastDataList = new ArrayList<>();

    //传入两行数据的方法
    public static List<String> parse(String str0, String str1) {
        String addressCode0 = getAddressCode(str0);
        String addressCode1 = getAddressCode(str1);
        int addrDistance = calculateIntervalOfAddressCode(addressCode0, addressCode1);
        if (addrDistance > 0x20) {
            //这里之后的地址和数据并没有完善处理，还有最后一行的补F也没处理
            // 就是最后剩下的数据没有返回，就只是留在restOfLastData
            parse1(str0);//在后面补F
            parse2(str1);//在前面补F
        } else if ((getDataLength(str0) < addrDistance * 2) && ((addrDistance < 0x20))) {
            //这种情况就是这一行虽然和后一行相差不超过0x20，但是这一行本应的数据长度addrDistance超过了它有效数据的超度
            //也就是有的地址并没有使用到，空缺在那里，需要后补F操作。
            //可是补F的数量不是参考0x20，而是参考addrDistance，所以要重写方法
//            Log.e("getDataLength", "getDataLength:" + getDataLength(str0));
            parse0(str0, addrDistance);//在中间补F
        } else {
            parse3(str0);
        }

//这个是返回restOfLastData，用一个集合存放，然后循环结束后取最后一个，单页处理可以，但是几页连在一起就不行
        if (restOfLastData != null) {
            restOfLastDataList.add(addr + restOfLastData);
        }
        //所以还是要想想返回的是啥
        return restOfLastDataList;
    }

    //传入两个参数（两行数据）（两行的操作好像不一样）
    public static String parse0(String str0, int addrDistance) {
        StringBuilder stringBuilder = new StringBuilder();
        String rawBeanString = null;
        String data0 = null;
        try {
            data0 = getData(str0);
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (restOfLastData != null) {
            stringBuilder.append(restOfLastData);
        }
        stringBuilder.append(data0);
        if (data0.length() < (addrDistance * 2)) {
            for (int i = 0; i < (addrDistance * 2 - data0.length()); i++) {
                stringBuilder.append("F");
            }
        }
        if (stringBuilder.length() < 64) {
            hasFinishedParseData = false;
            restOfLastData = stringBuilder.toString();
            Log.e("Help.rawBeanString", "addr01:" + addr);
        } else {
            hasFinishedParseData = true;    // 解析成功一条数据
            restOfLastData = stringBuilder.toString().substring(64);
            rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString().substring(0, 64).trim();
//                Log.e("stringBuilder", "stringBuilder:" + stringBuilder.toString());
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            Log.e("Help.rawBeanString", "addr02:" + addr);
            address = Integer.parseInt(addr, 16) * 2;
            address = address + 64;
            addr = changeToSixHexString(address / 2);
        }
        return rawBeanString;
    }

    public static String parse1(String str0) {
        StringBuilder stringBuilder = new StringBuilder();
        String rawBeanString = null;
        String data0 = null;
        try {
            data0 = getData(str0);
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (restOfLastData != null) {
            stringBuilder.append(restOfLastData);
        }
        stringBuilder.append(data0);
        //把整个为满的数据赋值给剩余数据-->wrong 2017/10/11  15:32
        //这个剩余数据不能设置为空，因为上一次填补的还会剩下
        while (stringBuilder.length() < 64) {
            stringBuilder.append("F");
        }

        hasFinishedParseData = true;    // 还未解析成功一条数据
        rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString();
        Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
        Log.e("Help.rawBeanString", "addr11:" + addr);
        if (stringBuilder.length() == 64) {
            hasFinishedParseData = true;    // 解析成功一条数据
            rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString();
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            Log.e("Help.rawBeanString", "addr12:" + addr);
        } else if (stringBuilder.length() > 64) {
            hasFinishedParseData = true;    //解析成功一条数据
            rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString().substring(0, 64);
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            Log.e("Help.rawBeanString", "addr12:" + addr);

            restOfLastData = stringBuilder.substring(64);
            address = Integer.parseInt(addr, 16) * 2;
            address = address + 64;
            addr = changeToSixHexString(address / 2);


        }
        return rawBeanString;
    }

    public static String parse2(String str1) {
        String rawBeanString = null;
        StringBuilder stringBuilder = new StringBuilder();
        //？
        restOfLastData = null;
        String data1 = null;
        try {
            data1 = getData(str1);
        } catch (Exception e) {
            e.printStackTrace();
        }
        addr = getAddressCode(str1);
        if ((Integer.parseInt(addr, 16) & 0x1F) != 0) {
            //剪切数据的长度
            int cutDataNum = 64 - (Integer.parseInt(addr, 16) & 0x1F) * 2;
            //剩余数据的长度
            String dataLength = Integer.toHexString((Integer.parseInt(addr, 16) & 0x1F) + 0x04);
            //这一行的起始地址
            addr = changeToSixHexString((Integer.parseInt(addr, 16) & 0xFFFFE0));
            restOfLastData = data1.substring(0, cutDataNum);
            stringBuilder.append(restOfLastData);
            strFF1 = stringBuilder.toString();
            for (int i = strFF1.length(); i < 64; i++) {
                strFF1 = "F" + strFF1;
            }
            Log.e("Help.rawBeanString", "addr21:" + addr);
            rawBeanString = "24-" + addr + "-20-" + strFF1;
            hasFinishedParseData = true;
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            restOfLastData = data1.substring(cutDataNum);
        }
        return rawBeanString;
    }

    public static String parse3(String str) {
        StringBuilder stringBuilder = new StringBuilder();
        String rawBeanString;
        int dataLength = getDataLength(str);
        int restOfLastDataLength = 0;
        String data = null;
        try {
            data = getData(str);
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (hasFinishedParseData || isFirstTimeToParse) {// 如果已经解析成功了一条数据或者是第一次解析
            isFirstTimeToParse = false;
            //Z:获取数据
            if (restOfLastData != null) {            // restOfLastData 包含纯数据
                stringBuilder.append(restOfLastData);
                restOfLastDataLength = restOfLastData.length();
            }
        } else {//Z:然后进入这里，反正先把数据和地址获取到
            // hasFinishedParseData 为 false 的时候 restOfLastData 一定不为空。
//            Log.e("Help", "None of hasFinishedParseData , isFirstTimeToParse");
            stringBuilder.append(restOfLastData);
            restOfLastDataLength = restOfLastData.length();
        }
//        if (data == null) {
//            restOfLastData = stringBuilder.append(data).toString();
//            hasFinishedParseData = false;
//            Log.e("Help.rawBeanString", "restOfLastDataParse31:" + restOfLastData);
//            String strEnd = "24-" + addr + "-20-" + restOfLastData;
//            parse1(strEnd);
//        }
//        Log.e("Help.rawBeanString", "addr30:" + addr);

        // 凑够64位数据的 剩余的数据 = 64 - 传进来的字符串的长度 - 上一次剩余的字符串的长度（第一次为 0 ）
        int restOfDataLength = 64 - dataLength - restOfLastDataLength;
//        Log.e("Help", "restOfDataLength : " + restOfDataLength + "  dataLength : " + dataLength + "  restOfLastDataLength : " + restOfLastDataLength);
        if (restOfDataLength > 0) {        // 还不够 64 个数据位,还需要填补
            if (data != null) {
                //把整个为满的数据赋值给剩余数据
                restOfLastData = stringBuilder.append(data).toString();
                lackLength = restOfDataLength;    // 本行剩余的长度
//                Log.e("Help", "未解析完成，有数据 ： " + restOfLastData);
                hasFinishedParseData = false;    // 还未解析成功一条数据
            }
            Log.e("Help.rawBeanString", "addr31:" + addr);
            return null;
        } else if (restOfDataLength == 0) {    // 刚好够 64 个数据位
            lackLength = 0;
            //刚好填充满没有剩余的数据
            restOfLastData = null;
            hasFinishedParseData = true;    // 已经解析成功了一条数据
            stringBuilder.append(data);
//            Log.e("Help", "刚好解析完成");
            //刚好解析完成地址就是这一行的起始地址
            addr = getAddressCode(str);
            rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString();
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            Log.e("Help.rawBeanString", "addr32:" + addr);
            address = Integer.parseInt(addr, 16) * 2;
            address = address + 64;
            addr = changeToSixHexString(address / 2);
            return rawBeanString;
        } else {
            // 超出了 64 个数据位(先把上一次剩下的数据填充到一行的前面，再从data中截取部分填补)
            // 这部分数据可凑够64个data.length() + （64 - dataLength - restOfLastDataLength）=
            // 64-restOfLastDataLength--->这个也就是把上一次剩下的填补之后需要data的数据个数
            String avaliableData = data.substring(0, data.length() + restOfDataLength);
            //data中有一部分数据是多余的
            restOfLastData = data.substring(data.length() + restOfDataLength);            // 这部分是剩余的数据
            lackLength = 64 + restOfDataLength;    //// 剩余的长度（就是下一行还dc 有多少空格没填满）
//            Log.e("Help", "data : " + data + "  avaliableData : " + avaliableData + "  restOfLastData : " + restOfLastData);
            hasFinishedParseData = true;    // 已经解析成功了一条数据
            stringBuilder.append(avaliableData);
            rawBeanString = "24-" + addr + "-20-" + stringBuilder.toString();
            Log.e("Help.rawBeanString", "rawBeanString:" + rawBeanString);
            Log.e("Help.rawBeanString", "addr33:" + addr);
            address = Integer.parseInt(addr, 16) * 2;
            address = address + 64;
            addr = changeToSixHexString(address / 2);
            return rawBeanString;
        }
    }
}

clsPublic:
/**
 * 这个是各种数据格式转换的工具类
 */
public class clsPublic {
    private final static byte[] hex = "0123456789ABCDEF".getBytes();

    private static int parse(char c) {
        if (c >= 'a')
            return (c - 'a' + 10) & 0x0f;
        if (c >= 'A')
            return (c - 'A' + 10) & 0x0f;
        return (c - '0') & 0x0f;
    }

    // 从字节数组到十六进制字符串转换
    //其实这个相当于 Integer.parseInt(str,16)
    public static String Bytes2HexString(byte[] b) {
        byte[] buff = new byte[2 * b.length];
        for (int i = 0; i < b.length; i++) {
            buff[2 * i] = hex[(b[i] >> 4) & 0x0f];
            buff[2 * i + 1] = hex[b[i] & 0x0f];
        }
        return new String(buff);
    }

    // 从十六进制字符串到字节数组转换
    //这个就是 Integer.toHexString(int);
    public static byte[] HexString2Bytes(String hexstr) {

        //报空指针证明并没有获取到字符串
        byte[] b = new byte[(hexstr.length()) / 2];
        int j = 0;
        for (int i = 0; i < b.length; i++) {
            char c0 = hexstr.charAt(j++);
            char c1 = hexstr.charAt(j++);
            b[i] = (byte) ((parse(c0) << 4) | parse(c1));
        }
        return b;
    }
}

s19LineBean:

/**
 * S19文件每一行的格式的实体类
 */

public class S19LineBean {
    /**
     * 记录类型：2个字符
     * 记录长度:  2个字符(即1个字节)，显示在记录中剩余的字节数。即
     * 记录长度 = 存储地址字节数 + 代码/数据字节数 + 校验和字节数
     * 存储地址:  2或3或4个字节(由记录类型决定)，用来表示代码/数据应该装载的起始地址。
     * 代码/数据:  0-64字符(即0-32字节)，表示需要下载到MCU中的数据。
     * 校验和:     2个字符(即1字节),校验数据，计算方法:
     * 校验和  =  0Xff – (记录长度 + 存储地址 + 代码/数据)
     * (注意，为校验和不是字符的校验和，而是实际二进制数的校验和)
     */
    //反正不管它是什么类型，全部用字符串，后面再转类型
    //记录类型
    private String motLineRecordType;
    //记录长度
    private String motLineRecordLength;
    //存储起始地址
    private String motLineRecordMemoryAddr;
    //代码/数据
    private String motLineRecordData;
    //校验和
    private String motLineRecordChecksum;

    //存储结束地址(如果是起始地址+20，那么就是下一行的起始地址)
    private String motLineRecordEndAddr;

    public S19LineBean() {
    }

    public S19LineBean(String motLineRecordType, String motLineRecordLength,
                       String motLineRecordMemoryAddr, String motLineRecordData,
                       String motLineRecordChecksum, String motLineRecordEndAddr) {
        this.motLineRecordType = motLineRecordType;
        this.motLineRecordLength = motLineRecordLength;
        this.motLineRecordMemoryAddr = motLineRecordMemoryAddr;
        this.motLineRecordData = motLineRecordData;
        this.motLineRecordChecksum = motLineRecordChecksum;
        this.motLineRecordEndAddr = motLineRecordEndAddr;
    }

    public String getMotLineRecordEndAddr() {
        return motLineRecordEndAddr;
    }

    public void setMotLineRecordEndAddr(String motLineRecordEndAddr) {
        this.motLineRecordEndAddr = motLineRecordEndAddr;
    }

    public String getMotLineRecordType() {
        return motLineRecordType;
    }

    public void setMotLineRecordType(String motLineRecordType) {
        this.motLineRecordType = motLineRecordType;
    }

    public String getMotLineRecordLength() {
        return motLineRecordLength;
    }

    public void setMotLineRecordLength(String motLineRecordLength) {
        this.motLineRecordLength = motLineRecordLength;
    }

    public void setMotLineRecordMemoryAddr(String motLineRecordMemoryAddr) {
        this.motLineRecordMemoryAddr = motLineRecordMemoryAddr;
    }

    public String getMotLineRecordMemoryAddr() {
        return motLineRecordMemoryAddr;
    }

    public String getMotLineRecordData() {
        return motLineRecordData;
    }

    public void setMotLineRecordData(String motLineRecordData) {
        this.motLineRecordData = motLineRecordData;
    }

    public String getMotLineRecordChecksum() {
        return motLineRecordChecksum;
    }

    public void setMotLineRecordChecksum(String motLineRecordChecksum) {
        this.motLineRecordChecksum = motLineRecordChecksum;
    }
    public String toFormerString() {
        return motLineRecordType +
                motLineRecordLength +
                motLineRecordMemoryAddr +
                motLineRecordData +
                motLineRecordChecksum;
    }

}
