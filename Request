最终得到的数据：
1.所有的地址&0x1F==0，而且是从小到大往下排列;
2.数据满行为64位;
3.分页处理，起始地址0x004000,结束地址最大为：0x024000,页大小为0x8000;
4.每页的最后一行数据不满64位则在后面用F填充；
5.数据之间存在空格，都用F填充：
    5.1 第一种就是addr2-addr1！=datalength1，&&addr2-addr1<64;(就是在第一行末尾补F就好，个数是（addr2-addr1）*2-datalength1)
    5.2 第二种是addr2-addr1！=datalength1，&&addr2-addr1>64,第一行在后面补F（个数为0x20*2-datalength1）,第二行在前面补F（
    地址变成addr2&0xFFFFE0,填补F的个数为（addr2&0x1F）*2）。
    
    比如：
    第一种情况：
    原始数据为：
    S20E00430800000000000000000000A6
    S207004312000000A3
    S212004315000000000000000000000000000095
    S20F004323000004000000000000000086
    S20B00432E0000000000000083                                                    datalength1=0B-4=7
    S22400433675CF00300004F304FD307600E70181066E2575C18206F52104FD887600C7143868  addr2-addr1=004336-00432E=8
    S22400435607F5FC02F53903F57603F59703F5D003C7077C06FE1EF52B040B8306E4016A0AD5  填补F的长度为：（8-7）*2=2
    
    处理后的数据为：
    24-004300-20-0000000000000000000000000000000000000000000000000000000000000000
    24-004320-20-000000000004000000000000000000000000000000FF75CF00300004F304FD30  这一行75CF003000……前面补了2个F
    24-004340-20-7600E70181066E2575C18206F52104FD887600C7143807F5FC02F53903F57603

    
    第二种的情况
    原始数据为：
    S20D00C1A0A30CF4A3FEF47FFEF3E9
    S22400C1CCB7A50CB7A40CD90FA70CD90FA90CB7A30C0BA30CB3778026007DCA0D33A30CD849  addr2-addr1=C1CC-C1A0=2C>0x20
    ……
    处理后的数据为：
    24-00c1a0-20-A30CF4A3FEF47FFEF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
    24-00c1c0-20-FFFFFFFFFFFFFFFFFFFFFFFFB7A50CB7A40CD90FA70CD90FA90CB7A30C0BA30C  addr2=C1CC&0xFFFFE0=C1C0
    24-00c1e0-20-B3778026007DCA0D33A30CD80CAF0CA7A30CFEEA0BA60CB3D1206E127EBF230B  补F的个数：C1CC&0x1F=C  C*2=24个F
    ……
